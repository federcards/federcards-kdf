Rem BasicCard Sample Source Code Template
Rem ------------------------------------------------------------------
Rem Copyright (C) 2008 ZeitControl GmbH
Rem You have a royalty-free right to use, modify, reproduce and 
Rem distribute the Sample Application Files (and/or any modified 
Rem version) in any way you find useful, provided that you agree 
Rem that ZeitControl GmbH has no warranty, obligations or liability
Rem for any Sample Application Files.
Rem ------------------------------------------------------------------
Option Explicit

#pragma ATR(HB="feder.cards/pg1")

#include Card.def

#include AES.DEF
#include SHA.DEF

#include string.bas
#include sha1hmac.bas
#include crypto.bas
#include factory_key.bas
#include session.card.bas
#include kdfservice.card.bas


public ERROR_DESC as string

' ******************************************************************************
' Error handling.

sub die_with_error(desc as string)
    ERROR_DESC = desc
    SW1SW2 = &H8864
end sub

sub die_silent()
    SW1SW2 = &H9000
end sub

command &H88 &H64 COMMAND_READ_ERROR(data as string)
    data = ERROR_DESC
end command


' ******************************************************************************
' Factory Reset
'
' Accepting a signed request (with factory key), this command resets the
' session auth key and the kdf service.

command &H88 &H00 COMMAND_FACTORY_RESET(data as string)
    ' Attempts a factory reset. This is done by sending the card a request,
    ' as encrypted by a key in factory_key.bas, containing the new auth key.
    private authkeyRet as byte
    authkeyRet = session_replace_authkey(data)
    if authkeyRet = 0 then
        ' failed
        data = "Bad request doing factory reset."
        die_with_error(data) : exit command
    end if
    ' Reset authorized. Continue to reset KDF service.
    call kdfservice_reset()
    data = "OK"
end command


' ******************************************************************************
' Get Session Challenge
'
' To start a session, the terminal program must request a challenge from card.
' The challenge is used then to establish a encrypted channel, and to prove that
' the terminal does know how to access this card.
'
' If a session is started but this command is called again, the current session
' will be terminated.

command &H88 &H02 COMMAND_GET_CHALLENGE(data as string)
    data = session_get_challenge()
end command


' ******************************************************************************
' Start Session
'
' Start a session by verifying a given password. The password is derived with
' doing a HMAC_SHA1 with key="password"+<session auth key> and
' message=<session challenge> as generated by COMMAND_GET_CHALLENGE.
'
' This password is sent in plaintext without encryption. It just ensures the
' terminal program is aware of session auth key. And even if this password is
' intercepted -- it's okay since the actual session encryption key is derived
' independently from this password.
'
' If a session is already started, this command will have no effect. It doesn't
' terminate a session.

command &H88 &H04 COMMAND_START_SESSION(data as string)
    if session_start(data) = 0 then
        data = "Start session failed."
        die_with_error(data) : exit command
    end if
    data = "OK"
end command


' ******************************************************************************
' Unlock the Card
'
' This call will accept a password from user terminal program. The password will
' be used to unlock(rotate) the KDF service.
'
' The KDF service is designed to be in same state when the same password is
' continously entered between sessions. And once different password is entered,
' that state will be changed permanently(rolling back to a previous password
' will not reverse). This prevents a malicious attacker trying to force the user
' reveal its password in any means.
'
' To use this command, the session must be started. After that, the input data
' is regarded as a password encrypted with session tempkey. 

command &H88 &H06 COMMAND_UNLOCK_CARD(data as string)
    private password as string
    if session_is_started() = 0 then
        data = "Session not started."
        die_with_error(data)
        exit command
    end if
    password = session_decrypt(data)
    if password = "" then
        data = "Communication error. Encryption error?"
        die_with_error(data) : exit command
    end if
    data = "OK"
    kdfservice_rotate(password)
end command

' ******************************************************************************
' Get a Password
'
' This is the only functional call for this card. It requests a pseudo-random
' password derived with the internal KDF service. The KDF service generates this
' password with its internal secret, which is protected by the user password.
'
' Input data is treated as session encrypted salt.

command &H88 &H08 COMMAND_GET_PASSWORD(data as string)
    private salt as string
    private result as string
    if session_is_started() = 0 then
        die_with_error("Session not started.") : exit command
    end if
    salt = session_decrypt(data)
    if salt = "" then
        die_with_error("Communication error. Encryption error?") : exit command
    end if
    result = kdfservice(salt)
    if result = "" then
        die_with_error("Must unlock first.") : exit command
    end if
    data = session_encrypt(result)
end command
